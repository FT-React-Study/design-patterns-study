# [Mediator-Middleware Pattern](https://patterns-dev-kr.github.io/design-patterns/mediator-middleware-pattern/)

## 미디에이터

### 정리

- 정의: 객체들 간의 복잡한 통신을 중재자(Mediator)가 관리하여 직접 의존 없이 상호작용하게 하는 패턴
- 특징: 결합도 감소, 중앙 집중식 제어, 다수 객체 간 상호작용 규칙의 단일화
- 장점: 객체 간 직접 의존 제거, 복잡한 상호작용을 한 곳에서 관리, 재사용 가능한 상호작용 규칙
- 단점: 중재자의 복잡도 증가 가능, 병목/단일 장애점(SPOF) 우려
- 활용: 실시간 통신(pub/sub), GraphQL 리졸버, 채팅 시스템 등

### 예제

```javascript
class Mediator {
  constructor() {
    this.channels = {};
  }

  subscribe(channel, callback) {
    if (!this.channels[channel]) {
      this.channels[channel] = [];
    }
    this.channels[channel].push(callback);
  }

  publish(channel, data) {
    if (this.channels[channel]) {
      this.channels[channel].forEach((callback) => callback(data));
    }
  }
}

// 사용 예시
const mediator = new Mediator();

// 구독자들
mediator.subscribe("user-login", (user) => {
  console.log(`Logging user activity: ${user.name} logged in`);
});

mediator.subscribe("user-login", (user) => {
  console.log(`Sending welcome email to: ${user.email}`);
});

mediator.subscribe("user-login", (user) => {
  console.log(`Updating user status: ${user.name} is online`);
});

// 발행
mediator.publish("user-login", { name: "John", email: "john@example.com" });
```

```javascript
class WebSocketMediator {
  constructor() {
    this.clients = new Map();
    this.rooms = new Map();
  }

  subscribe(client, room) {
    if (!this.rooms.has(room)) {
      this.rooms.set(room, []);
    }
    this.rooms.get(room).push(client);
    this.clients.set(client, room);
  }

  publish(room, message, sender) {
    const clients = this.rooms.get(room);
    if (clients) {
      clients.forEach((client) => {
        if (client !== sender) {
          client.send(message);
        }
      });
    }
  }
}
```

GraphQL의 resolver가 클라이언트와 데이터 소스 간의 중재자 역할을 함

```javascript
const resolvers = {
  Query: {
    // Mediator가 클라이언트 요청을 적절한 데이터 소스로 중재
    user: (parent, args, context) => {
      return context.dataSources.userAPI.getUser(args.id);
    },
  },
};
```

```javascript
class ChatMediator {
  constructor() {
    this.users = [];
    this.rooms = new Map();
  }

  addUser(user) {
    this.users.push(user);
    user.setMediator(this);
  }

  createRoom(roomId) {
    this.rooms.set(roomId, []);
  }

  joinRoom(user, roomId) {
    if (!this.rooms.has(roomId)) {
      this.createRoom(roomId);
    }
    this.rooms.get(roomId).push(user);
  }

  sendMessage(from, message, roomId) {
    const room = this.rooms.get(roomId);
    if (room) {
      room.forEach((user) => {
        if (user !== from) {
          user.receive(message, from.name);
        }
      });
    }
  }
}

class User {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }

  setMediator(mediator) {
    this.mediator = mediator;
  }

  send(message, roomId) {
    this.mediator.sendMessage(this, message, roomId);
  }

  receive(message, fromUser) {
    console.log(`${this.name} received: "${message}" from ${fromUser}`);
  }
}

// 사용
const chatMediator = new ChatMediator();

const john = new User("John");
const jane = new User("Jane");
const bob = new User("Bob");

chatMediator.addUser(john);
chatMediator.addUser(jane);
chatMediator.addUser(bob);

chatMediator.joinRoom(john, "general");
chatMediator.joinRoom(jane, "general");
chatMediator.joinRoom(bob, "general");

john.send("Hello everyone!", "general");
jane.send("Hi John!", "general");
```

## 미들웨어

### 정리

- 정의: 요청/응답 흐름 중간에 공통 관심사를 체인으로 연결해 단계적으로 처리하는 패턴
- 특징: 체인 구성, 순차 실행, 합성 가능, 단일 책임의 단계화
- 장점: 횡단 관심사(인증/로깅/검증 등) 분리, 재사용/확장 용이, 구성 기반의 유연성
- 단점: 호출 오버헤드, 체인이 길어질수록 디버깅 난이도 증가, 순서 의존성 이슈
- 활용: 서버 요청 파이프라인(Next.js/Express), 클라이언트 상태 라이브러리(Zustand) 등

### 예제

```javascript
class MiddlewareManager {
  constructor() {
    this.middlewares = [];
  }

  use(middleware) {
    this.middlewares.push(middleware);
  }

  execute(context) {
    let index = 0;

    const next = () => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index++];
        middleware(context, next);
      }
    };

    next();
  }
}

// 미들웨어 함수들
const loggingMiddleware = (context, next) => {
  console.log(`Request: ${context.method} ${context.url}`);
  next();
};

const authMiddleware = (context, next) => {
  if (context.headers.authorization) {
    context.user = { id: 1, name: "John" };
    next();
  } else {
    console.log("Unauthorized request");
  }
};

const validationMiddleware = (context, next) => {
  if (context.body && context.body.email) {
    next();
  } else {
    console.log("Invalid request body");
  }
};

// 사용
const app = new MiddlewareManager();
app.use(loggingMiddleware);
app.use(authMiddleware);
app.use(validationMiddleware);

app.execute({
  method: "POST",
  url: "/users",
  headers: { authorization: "Bearer token123" },
  body: { email: "john@example.com" },
});
```

```javascript
// middleware.js
import { NextResponse } from "next/server";

export function middleware(request) {
  // 인증 체크
  if (!request.nextUrl.pathname.startsWith("/api/auth")) {
    const token = request.cookies.get("auth-token");
    if (!token) {
      return NextResponse.redirect(new URL("/login", request.url));
    }
  }

  // 로깅
  console.log(`${request.method} ${request.nextUrl.pathname}`);

  return NextResponse.next();
}

export const config = {
  matcher: "/api/:path*",
};
```

```javascript
import { persist } from "zustand/middleware";

const useStore = create(
  persist(
    (set, get) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 })),
    }),
    {
      name: "counter-storage", // localStorage key
    }
  )
);
```

### 현재 어떻게 사용되는지

- 실시간 통신: WebSocket, Server-Sent Events의 pub/sub 관리(미디에이터)
- API 게이트웨이: 마이크로서비스 간 통신 중재(미디에이터)
- 상태 관리: Zustand의 미들웨어 체인(미들웨어)
- 서버사이드: Next.js, Express.js의 요청 처리 파이프라인(미들웨어)
- GraphQL: 클라이언트와 데이터 소스 간 중재(미디에이터)
