# [Mixin Pattern](https://patterns-dev-kr.github.io/design-patterns/mixin-pattern/)

## 정의

- 여러 개체나 클래스의 기능을 조합하여 새로운 객체를 만드는 디자인 패턴
- 상속의 제약 없이 다양한 기능을 객체에 추가할 수 있는 방법 제공
- JavaScript에서 Object.assign()을 통해 쉽게 구현 가능

## 특징

- 횡단 관심사 처리: 여러 클래스에서 공통으로 사용되는 기능을 별도 모듈로 분리
- 조합 가능성: 필요한 기능만 선택하여 조합 가능
- 다중 상속 대안: 단일 상속의 한계를 극복

## 기본 믹스인

```javascript
// 기본 믹스인 객체들
const CanWalk = {
  walk() {
    console.log(`${this.name} is walking`);
  },
};

const CanSwim = {
  swim() {
    console.log(`${this.name} is swimming`);
  },
};

const CanFly = {
  fly() {
    console.log(`${this.name} is flying`);
  },
};

// 믹스인을 사용하여 객체 생성
function createBird(name) {
  return Object.assign(
    {
      name,
      type: "bird",
    },
    CanWalk,
    CanFly
  );
}

function createFish(name) {
  return Object.assign(
    {
      name,
      type: "fish",
    },
    CanSwim
  );
}

function createDuck(name) {
  return Object.assign(
    {
      name,
      type: "duck",
    },
    CanWalk,
    CanSwim,
    CanFly
  );
}

// 사용
const sparrow = createBird("Sparrow");
sparrow.walk(); // Sparrow is walking
sparrow.fly(); // Sparrow is flying

const goldfish = createFish("Goldfish");
goldfish.swim(); // Goldfish is swimming

const duck = createDuck("Duck");
duck.walk(); // Duck is walking
duck.swim(); // Duck is swimming
duck.fly(); // Duck is flying
```

## SCSS 믹스인

```scss
// 기본/인자/기본값 예시
@mixin btn($bg, $color: #fff) {
  background: $bg;
  color: $color;
  border: 0;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
}

.btn-primary {
  @include btn(#0d6efd);
}
.btn-danger {
  @include btn(#dc3545, #fff);
}
```

```scss
// @content로 래핑하는 카드 유틸
@mixin card {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-radius: 0.75rem;
  @content;
}

.product {
  @include card {
    padding: 1rem;
    background: #fff;
  }
}
```

```scss
// 반응형 브레이크포인트 헬퍼
$breakpoints: (
  sm: 576px,
  md: 768px,
  lg: 992px,
);

@mixin up($bp) {
  @media (min-width: map-get($breakpoints, $bp)) {
    @content;
  }
}

.grid {
  display: grid;
  grid-template-columns: 1fr;
  @include up(md) {
    grid-template-columns: 1fr 1fr;
  }
  @include up(lg) {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

```scss
// 테마 토큰 접근
$theme: (
  primary: #4f46e5,
  danger: #ef4444,
);

@mixin text-color($token) {
  color: map-get($theme, $token);
}

.link-primary {
  @include text-color(primary);
}
```

```scss
// 접근성 유틸
@mixin visually-hidden {
  position: absolute !important;
  width: 1px;
  height: 1px;
  overflow: hidden;
  clip: rect(1px, 1px, 1px);
  white-space: nowrap;
}

.sr-only {
  @include visually-hidden;
}
```

## 팩토리 함수와 믹스인

```javascript
// 기능별 믹스인들
const EventEmitter = {
  on(event, callback) {
    this.events = this.events || {};
    this.events[event] = this.events[event] || [];
    this.events[event].push(callback);
  },

  emit(event, data) {
    if (this.events && this.events[event]) {
      this.events[event].forEach((callback) => callback(data));
    }
  },

  off(event, callback) {
    if (this.events && this.events[event]) {
      this.events[event] = this.events[event].filter((cb) => cb !== callback);
    }
  },
};

const Serializable = {
  serialize() {
    return JSON.stringify(this.getData());
  },

  deserialize(json) {
    const data = JSON.parse(json);
    Object.assign(this, data);
  },

  getData() {
    const { serialize, deserialize, getData, ...data } = this;
    return data;
  },
};

const Timestamped = {
  updateTimestamp() {
    this.lastModified = new Date();
  },

  getAge() {
    return Date.now() - (this.createdAt || Date.now());
  },
};

// 믹스인을 조합하는 팩토리 함수
function createUser(name, email) {
  const user = {
    name,
    email,
    createdAt: new Date(),
  };

  return Object.assign(user, EventEmitter, Serializable, Timestamped);
}

// 사용
const user = createUser("John Doe", "john@example.com");

// 이벤트 기능
user.on("nameChanged", (newName) => {
  console.log(`Name changed to: ${newName}`);
});

// 타임스탬프 기능
user.updateTimestamp();

// 직렬화 기능
const userJson = user.serialize();
console.log(userJson);

// 이벤트 발생
user.name = "Jane Doe";
user.emit("nameChanged", user.name);
```

## Tailwind에서의 선언적 믹스인(@apply/@utility)

```css
/* Tailwind v3: @apply를 components/utilities 레이어에서 사용 */
@layer components {
  .btn-primary {
    @apply inline-flex items-center gap-2 px-3 py-2 rounded-md
           bg-indigo-600 text-white hover:bg-indigo-700;
  }
}
```

```css
/* Tailwind v4: @utility로 커스텀 유틸리티 정의 */
@utility btn-primary {
  @apply inline-flex items-center gap-2 px-3 py-2 rounded-md
         bg-indigo-600 text-white hover:bg-indigo-700;
}
```

위 선언은 매개변수 없는 고정 조합이지만, 반복되는 유틸 묶음을 의미 있는 이름으로 승격해 재사용한다는 점에서 CSS 레벨의 믹스인과 유사하게 작동한다.

## 함수형 믹스인

```javascript
// 함수형 믹스인들
const withValidation = (obj) => ({
  ...obj,
  validate(rules) {
    const errors = [];
    Object.keys(rules).forEach((field) => {
      const rule = rules[field];
      const value = this[field];

      if (rule.required && !value) {
        errors.push(`${field} is required`);
      }
      if (rule.minLength && value && value.length < rule.minLength) {
        errors.push(`${field} must be at least ${rule.minLength} characters`);
      }
      if (rule.email && value && !/\S+@\S+\.\S+/.test(value)) {
        errors.push(`${field} must be a valid email`);
      }
    });

    return errors;
  },
});

const withCache = (obj) => ({
  ...obj,
  cache: new Map(),

  memoize(key, fn) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const result = fn();
    this.cache.set(key, result);
    return result;
  },

  clearCache() {
    this.cache.clear();
  },
});

const withLogging = (obj) => ({
  ...obj,
  logs: [],

  log(message) {
    this.logs.push({
      message,
      timestamp: new Date(),
    });
    console.log(`[${new Date().toISOString()}] ${message}`);
  },

  getLogs() {
    return this.logs;
  },
});

// 믹스인 조합 함수
const compose =
  (...mixins) =>
  (obj) => {
    return mixins.reduce((acc, mixin) => mixin(acc), obj);
  };

// 사용
const createAdvancedUser = compose(withValidation, withCache, withLogging);

const user = createAdvancedUser({
  name: "John",
  email: "john@example.com",
});

// 유효성 검사
const errors = user.validate({
  name: { required: true, minLength: 2 },
  email: { required: true, email: true },
});
console.log(errors); // []

// 로깅
user.log("User created");

// 캐싱
const expensiveOperation = () => {
  user.log("Performing expensive operation");
  return "expensive result";
};

const result1 = user.memoize("expensive", expensiveOperation);
const result2 = user.memoize("expensive", expensiveOperation); // 캐시에서 반환

console.log(user.getLogs());
```

## 장단점

### 장점

- 코드 재사용성: 기능을 독립적인 모듈로 분리하여 재사용
- 조합 가능성: 필요한 기능만 선택하여 조합 가능
- 유연성: 상속의 제약 없이 다양한 기능 조합
- 관심사 분리: 각 믹스인이 특정 기능에만 집중

### 단점

- 이름 충돌: 같은 이름의 메소드가 있을 때 충돌 가능
- 암시적 의존성: 믹스인 간의 의존성이 명확하지 않을 수 있음
- 복잡성 증가: 너무 많은 믹스인 사용 시 이해하기 어려워짐
- 디버깅 어려움: 메소드의 출처를 추적하기 어려울 수 있음

## 실제로 어디에 쓰이는가

### 스타일링/CSS 생태계

- SCSS/Sass: `@mixin`과 `@include`로 토큰/반응형/접근성 유틸을 재사용
- Tailwind CSS: `@apply`/`@utility`로 유틸리티 조합을 선언적 믹스인처럼 재사용

### 프론트엔드/백엔드 일반

- Vue.js: 믹스인(또는 Composition API)으로 컴포넌트 기능 확장
- Express.js: 미들웨어를 통한 기능 확장

### 유틸리티 라이브러리와 게임 개발

- Lodash: 유틸리티 함수들의 조합
- 게임 개발: 엔티티 컴포넌트 시스템

### 현재 어떻게 사용되는지

- CSS 전처리기(SCSS)에서 팀 공통 토큰/반응형/레이아웃/접근성 유틸을 믹스인으로 표준화
- Tailwind 프로젝트에서 반복 유틸 묶음을 `@apply`/`@utility`로 캡슐화하여 재사용
- JavaScript 영역에서는 클래스 상속 대신 객체 조합/함수형 믹스인/팩토리 함수를 통해 필요한 기능만 선택적으로 결합
