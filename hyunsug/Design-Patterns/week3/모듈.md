# [Module Pattern](https://patterns-dev-kr.github.io/design-patterns/module-pattern/)

## 정의

- JavaScript에서 코드를 캡슐화하고 재사용 가능한 모듈로 구성하는 디자인 패턴
- IIFE(즉시실행함수)와 클로저를 활용하여 모듈의 private/public 인터페이스 구현
- ES2015 이전 JavaScript에 진짜 모듈 시스템이 없던 시절, 함수 스코프를 "비틀어서" 모듈처럼 사용하던 해킹 기법

## 특징

- 전역 네임스페이스 오염 방지 (함수 스코프를 통한 격리)
- 클로저를 통한 데이터 은닉과 캡슐화 제공
- ESM(ES Modules) 등장 후에는 언어 차원의 진짜 모듈 시스템으로 대체됨

## 기본 패턴

```javascript
const MyModule = (function() {
  let privateVariable = 0;
  
  function privateFunction() {
    console.log('This is private');
  }
  
  return {
    publicMethod: function() {
      privateVariable++;
      privateFunction();
      return privateVariable;
    },
    
    publicVariable: 'I am public'
  };
})();

// 사용
console.log(MyModule.publicMethod()); // 1
console.log(MyModule.publicVariable); // 'I am public'
// console.log(MyModule.privateVariable); // undefined
```

## 네임스페이스 패턴

객체의 속성(메서드)에 IIFE를 할당하여 여러 모듈을 묶어서 관리하는 형태

```javascript
const MyApp = MyApp || {};

MyApp.utils = (function() {
  return {
    formatDate: function(date) {
      return date.toLocaleDateString();
    },
    
    validateEmail: function(email) {
      return /\S+@\S+\.\S+/.test(email);
    }
  };
})();

MyApp.components = (function() {
  return {
    createButton: function(text) {
      const button = document.createElement('button');
      button.textContent = text;
      return button;
    }
  };
})();
```

### React에서의 활용 예시

React의 memoized component에서 `displayName`을 선언할 때도 유사한 네임스페이스 형태로 사용됨

```javascript
// React.memo의 displayName 설정
const UserProfile = React.memo(({ user }) => (
  <div>{user.name}</div>
));

// 네임스페이스 형태로 displayName 설정 (디버깅용)
UserProfile.displayName = 'UserProfile';

// 또는 중첩된 네임스페이스 형태
const Components = {
  UserProfile: React.memo(({ user }) => <div>{user.name}</div>)
};
Components.UserProfile.displayName = 'Components.UserProfile';
```

이는 모듈 패턴의 네임스페이스 개념과는 다르게, 단순히 객체 속성에 함수나 컴포넌트를 할당하는 형태로 React DevTools에서 컴포넌트 식별을 위한 메타데이터 설정에 가까움.

## ESM (ES Modules) - 진짜 모듈 시스템

ES2015+에서 도입된 언어 차원의 진짜 모듈 시스템으로, 파일이 모듈의 기본 단위가 됨

```javascript
// math.js
export const PI = 3.14159;

export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// 기본 내보내기
export default function subtract(a, b) {
  return a - b;
}
```

```javascript
// main.js
import subtract, { PI, add, multiply } from './math.js';

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3
```

### IIFE 패턴 vs ESM 비교

| 구분 | IIFE 모듈 패턴 | ESM |
|------|---------------|-----|
| 구현 방식 | 함수 스코프를 "비틀어서" 활용 | 언어 차원의 진짜 모듈 시스템 |
| 의존성 관리 | 전역 변수나 수동 의존성 주입 | `import`/`export`로 명시적 관리 |
| 정적 분석 | 불가능 (런타임에 결정) | 가능 (빌드 타임에 분석) |
| 트리 쉐이킹 | 지원 안됨 | 지원됨 |
| 번들링 최적화 | 어려움 | 쉬움 |

## 장단점

### 장점

- 캡슐화 강제: 클로저를 통한 데이터 은닉과 공개 인터페이스 분리
- 전역 스코프 오염 방지: 함수 스코프를 통한 격리 효과
- 즉시 사용 가능: 별도의 빌드 과정 없이 브라우저에서 바로 실행
- 네임스페이스 관리: 관련 기능들을 논리적으로 그룹화

### 단점

- 의존성 관리 복잡: 모듈 간 의존성을 수동으로 관리해야 함
- 정적 분석 불가: 런타임에 결정되는 구조로 빌드 도구 최적화 어려움
- 메모리 오버헤드: 클로저로 인한 추가 메모리 사용
- 테스트 어려움: private 멤버에 대한 단위 테스트가 복잡함

## 실제로 어디에 쓰이는가

### 레거시 코드베이스

```javascript
const UserModule = (function() {
  let users = [];
  
  function validateUser(user) {
    return user.name && user.email;
  }
  
  return {
    addUser: function(user) {
      if (validateUser(user)) {
        users.push(user);
        return true;
      }
      return false;
    },
    
    getUsers: function() {
      return users.slice(); // 복사본 반환
    },
    
    getUserCount: function() {
      return users.length;
    }
  };
})();

// 사용
UserModule.addUser({ name: 'John', email: 'john@example.com' });
console.log(UserModule.getUserCount()); // 1
```

### 현재 어떻게 사용되는지

- ESM 사용 가능 환경: 굳이 IIFE 패턴을 쓸 필요 없음
- 레거시 브라우저 지원: 여전히 유용할 수 있음
- 즉시 실행이 필요한 초기화 코드: 제한적으로 활용 가능
- 라이브러리 개발: UMD 패턴 등에서 부분적으로 사용됨