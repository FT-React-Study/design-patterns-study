# [Proxy Pattern](https://patterns-dev-kr.github.io/design-patterns/proxy-pattern/)

## 내용정리

- Proxy 패턴은 실제 객체에 대한 접근을 제어하기 위해 대리 객체를 두는 구조 패턴
- 클라이언트는 프록시를 통해 실제 객체에 접근하며, 이 과정에서 접근 통제, 지연 실행, 캐싱 등의 로직을 주입할 수 있음
- JavaScript에서는 전통적인 클래스 방식뿐만 아니라 ES6 `Proxy` 객체를 활용한 동적 방식도 가능

## 프록시 패턴이란

- “대상 객체에 대한 접근을 대신 수행하거나 가로채는 객체”를 프록시라고 함
- 프록시는 대상 객체의 인터페이스를 그대로 유지하면서 중간에 원하는 동작을 삽입할 수 있음
- 성능, 보안, 동기화, 로깅, 접근 제어 등 다양한 목적에 따라 활용됨

## JavaScript의 ES6 Proxy 객체

- ES6에서 제공하는 `Proxy`는 기존 객체를 감싸서 속성 접근, 설정, 삭제, 호출 등 기본 동작을 커스터마이징할 수 있게 함

```js
const proxy = new Proxy(target, handler);
```

### 주요 활용 예:

- 속성 접근/설정 감시 및 유효성 검사
- 상태 변경 감지 및 옵저버 패턴 구현
- API 호출 자동화
- 데이터 변환/정규화

### 프론트엔드에서의 Proxy 활용 예

- MobX의 상태 추적
- REST API 호출용 래퍼
- 사용자 설정 또는 권한 기반 인터페이스
- 캐시 계층 또는 가상 데이터 생성기

## 장단점

### 장점

- 객체 접근 로직 분리 및 제어
- 지연 로딩, 캐싱, 로깅 등 다양한 목적에 적합
- 기존 객체 구조를 변경하지 않고 기능 추가 가능

### 단점

- 프록시와 실제 객체 간 분리가 디버깅을 어렵게 함
- 프록시 레이어로 인해 성능 오버헤드 발생 가능
- 과도하게 사용 시 구조 복잡도 증가

## 번외 - 네트워크 Proxy 서버와의 유사점과 차이점

### 유사점

- 중간자 역할: 둘 다 대상(객체 또는 서버)에 직접 접근하지 않고 중간에서 접근을 가로채거나 중계하는 구조
- 접근 제어: 원래 대상에 대한 접근을 제한하거나 필터링할 수 있음
- 추가 로직 삽입 가능: 실제 동작 전에 로깅, 검증, 캐싱, 보안 검사 등 부가 처리를 삽입할 수 있음
- 투명성: 사용하는 입장에서는 실제 대상과의 차이를 느끼지 않도록 인터페이스를 동일하게 유지

### 차이점

| 항목          | 디자인 패턴 Proxy                               | 네트워크 Proxy 서버                                |
| ------------- | ----------------------------------------------- | -------------------------------------------------- |
| **대상**      | 프로그램 내의 객체                              | 네트워크 상의 서버 또는 웹 리소스                  |
| **역할**      | 객체의 속성/메서드 접근 제어                    | 클라이언트와 서버 간의 트래픽 중계                 |
| **위치**      | 애플리케이션 내부 구조                          | 네트워크 경계(로컬 PC, 라우터, 회사 게이트웨이 등) |
| **적용 예시** | 속성 접근 감시, 가상 이미지 로딩, API 요청 래퍼 | 캐시 서버, 방화벽, VPN, 프록시 브라우저            |
| **기술 기반** | JavaScript Proxy 객체, 클래스 구조              | HTTP/S, SOCKS, 리버스 프록시 서버 구성 등          |

- 개념적으로는 "대상에 직접 접근하지 않고 대리 처리한다"는 공통점이 있지만
- 적용되는 환경과 대상은 다르며, 각각 프로그래밍 설계 vs. 네트워크 인프라에 해당함.

## 번외 - Vue3의 `reactive` vs React state

| 항목                 | Vue 3 (`reactive`)                               | React (`useState`, `useReducer`)                    |
| -------------------- | ------------------------------------------------ | --------------------------------------------------- |
| 상태 추적 방식       | Proxy 기반 자동 추적                             | 명시적 함수 호출 (setState)                         |
| 변경 감지            | 객체 속성 접근/수정 시 자동 감지 (get/set trap)  | setState 호출 시에만 변경으로 간주                  |
| 의존성 추적          | 속성 접근 시 자동으로 종속성 등록                | 훅 호출 순서에 따라 암묵적 추적                     |
| 리렌더링 트리거      | Proxy의 set trap이 변경을 감지하면 컴포넌트 갱신 | setState 호출이 컴포넌트 갱신을 트리거              |
| 데이터 구조          | 중첩 객체도 자동으로 반응형 처리                 | 깊은 구조는 수동 관리 필요 (useState는 얕은 동기화) |
| 프레임워크 내부 구조 | Proxy → Dependency Tracker → Effect Queue        | Fiber → State Queue → Reconciliation                |

- Vue 3의 reactive는 Proxy 기반의 선언적 상태 시스템으로, 상태를 직접 조작하는 것만으로도 UI가 자동 반응함
- React의 state는 명시적 업데이트 기반 시스템으로, 상태가 바뀐다는 사실을 React에 직접 알려야 동작함
