# [프로토타입](https://patterns-dev-kr.github.io/design-patterns/prototype-pattern/)

- 프로토타입 패턴은 객체를 생성할 때 기존 객체를 클론하여 새로운 객체를 만드는 패턴으로, 인스턴스를 직접 생성하는 것이 아닌 존재하는 인스턴스를 복제하여 사용
- 클래스 기반 객체 지향 프로그래밍과는 조금 다른 방향성을 지님
- 원형(Prototype) 객체가 복제될 수 있는 인터페이스를 제공해야 하며, 이를 통해 클라이언트는 구체적인 클래스에 의존하지 않고 객체를 생성 가능

## 클래스 대비 장점

- 객체 생성 비용이 크거나 초기화 과정이 복잡한 경우 (ex. 복잡한 설정, 외부 리소스 로딩 등)
- 런타임까지 어떤 클래스의 객체를 생성해야 하는지 알기 어려운 경우
- 유사한 객체를 반복해서 생성해야 하는 경우, 매번 모든 초기값을 재설정하는 번거로움을 줄일 수 있음

> 이미 있는 걸 베껴 쓰지, 매번 새로 만들고 초기화하느니

- 클래스 기반 생성의 또 다른 제한점: 객체의 복제본을 만들기 위해 객체의 구체적인 클래스에 의존해야 함
  - 이는 OCP(개방-폐쇄 원칙)에 어긋날 수 있음 → 클래스 수정 없이 객체를 다양하게 생성하고자 할 때 제약이 됨

## 그에 따른 클론, 복제라는 키워드

- 어떠한 객체를 원형으로 삼아 복제한 새로운 객체를 만드는 방식
- 즉, 프로토타입에서 출발하는 패턴이라는 의미의 `Prototype` 패턴
- 복제는 얕은 복사(shallow copy) 또는 깊은 복사(deep copy) 방식 모두를 포함할 수 있으며, 이 부분은 구현에 따라 달라짐

## JavaScript의 프로토타입

### 프로토타입 상속을 선택한 역사적 배경

- JavaScript는 1995년 Brendan Eich가 10일 만에 만든 언어로, 유연성과 동적 특성을 핵심으로 설계됨
- 웹 브라우저라는 제한된 환경에서 빠른 실행 속도와 메모리 효율성이 중요했음
- 클래스 기반 상속의 경우 컴파일 타임에 타입과 구조가 결정되지만, 프로토타입 상속은 런타임에 객체 구조를 동적으로 변경할 수 있어 웹의 동적 특성에 적합
- Self 언어의 영향을 받아 객체가 직접 다른 객체를 상속하는 방식을 채택 - 클래스라는 중간 단계 없이 더 직관적이고 간단한 구조

### JavaScript 프로토타입의 특징

- JavaScript는 클래스 기반 언어가 아니며, 프로토타입 기반(prototype-based) 언어임
- 객체가 다른 객체를 원형으로 삼아 직접 상속하며, `Object.create(proto)`를 통해 기존 객체를 기반으로 새로운 객체 생성 가능
- 이는 클래스 없이도 프로토타입 패턴을 자연스럽게 구현할 수 있게 해줌

### 프로토타입 체인과 위임

- 모든 JavaScript 객체는 `[[Prototype]]` 내부 슬롯을 가지며, 이를 통해 프로토타입 체인을 형성
- 객체에서 프로퍼티나 메서드를 찾을 때, 해당 객체에 없으면 프로토타입 체인을 따라 상위 객체에서 탐색
- 이는 위임(delegation) 패턴으로, 상속이 아닌 다른 객체에게 작업을 위임하는 방식
- `Object.getPrototypeOf()`, `Object.setPrototypeOf()`, `__proto__` 등을 통해 프로토타입에 접근 가능

```js
// 프로토타입 체인 예시
const animal = {
  eat() { console.log('eating...'); }
};

const dog = Object.create(animal);
dog.bark = function() { console.log('woof!'); };

dog.eat(); // 'eating...' - animal의 메서드를 위임받아 실행
dog.bark(); // 'woof!' - 자신의 메서드 실행
```

### 프로토타입 패턴과 JavaScript의 자연스러운 결합

```js
// 기본 프로토타입 패턴 구현
const baseShape = {
  type: "circle",
  color: "red",
  clone() {
    return Object.assign({}, this);
  },
  // 깊은 복사를 위한 메서드
  deepClone() {
    return JSON.parse(JSON.stringify(this));
  }
};

const anotherShape = baseShape.clone();
anotherShape.color = "blue";
console.log(baseShape.color); // 'red' - 원본은 변경되지 않음
console.log(anotherShape.color); // 'blue'
```

### 생성자 함수와 프로토타입

```js
// 생성자 함수를 통한 프로토타입 활용
function Shape(type, color) {
  this.type = type;
  this.color = color;
}

Shape.prototype.clone = function() {
  return new this.constructor(this.type, this.color);
};

Shape.prototype.describe = function() {
  return `${this.color} ${this.type}`;
};

const circle = new Shape("circle", "red");
const clonedCircle = circle.clone();
console.log(clonedCircle.describe()); // "red circle"
```

### ES6 클래스와 프로토타입

```js
// ES6 클래스도 내부적으로는 프로토타입을 사용
class ModernShape {
  constructor(type, color) {
    this.type = type;
    this.color = color;
  }
  
  clone() {
    return new this.constructor(this.type, this.color);
  }
  
  // 정적 메서드로 팩토리 패턴과 결합
  static createPrototype(type, color) {
    const prototype = new this(type, color);
    prototype.isPrototype = true;
    return prototype;
  }
}

const shapePrototype = ModernShape.createPrototype("rectangle", "green");
const newShape = shapePrototype.clone();
```
