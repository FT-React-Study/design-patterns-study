# [프로토타입](https://patterns-dev-kr.github.io/design-patterns/prototype-pattern/)

## 정의

- 기존 객체 클론을 통한 새 객체 생성 패턴
- 인스턴스 직접 생성 대신 존재하는 인스턴스 복제 활용
- 클래스 기반 객체 지향과 다른 방향성
- 원형 객체의 복제 가능 인터페이스 제공으로 구체 클래스 의존성 제거

## 장점

- 객체 생성 비용이 크거나 초기화 과정이 복잡한 경우 효율적 (복잡한 설정, 외부 리소스 로딩 등)
- 런타임까지 생성할 클래스를 모르는 상황에서 유연한 객체 생성
- 유사 객체 반복 생성 시 초기값 재설정 번거로움 제거
- 클래스 기반 생성의 구체 클래스 의존성 문제 해결
- OCP(개방-폐쇄 원칙) 준수로 클래스 수정 없는 다양한 객체 생성

## 핵심 개념

- 원형 객체를 복제하여 새 객체 생성
- 프로토타입에서 출발하는 패턴
- 얕은 복사(shallow copy) 또는 깊은 복사(deep copy) 지원
- 구현 방식에 따른 복제 전략 선택

## JavaScript의 프로토타입

### 프로토타입 상속 선택 배경

- 1995년 Brendan Eich가 10일 만에 개발한 언어로 유연성과 동적 특성 중시
- 웹 브라우저 환경에서 빠른 실행 속도와 메모리 효율성 요구
- 클래스 기반 상속: 컴파일 타임에 타입/구조 결정
- 프로토타입 상속: 런타임 객체 구조 동적 변경으로 웹의 동적 특성에 적합
- Self 언어 영향으로 클래스 중간 단계 없는 직접 객체 상속 방식 채택

### JavaScript 프로토타입 특징

- 프로토타입 기반(prototype-based) 언어로 클래스 기반 언어 아님
- 객체가 다른 객체를 원형으로 직접 상속
- `Object.create(proto)`로 기존 객체 기반 새 객체 생성
- 클래스 없이도 프로토타입 패턴 자연스러운 구현

### 프로토타입 체인과 위임

- 모든 JavaScript 객체의 `[[Prototype]]` 내부 슬롯으로 프로토타입 체인 형성
- 프로퍼티/메서드 탐색 시 객체에 없으면 프로토타입 체인 상위 객체에서 검색
- 위임(delegation) 패턴으로 상속 대신 다른 객체에 작업 위임
- `Object.getPrototypeOf()`, `Object.setPrototypeOf()`, `__proto__`를 통한 프로토타입 접근

```js
// 프로토타입 체인 예시
const animal = {
  eat() {
    console.log("eating...");
  },
};

const dog = Object.create(animal);
dog.bark = function () {
  console.log("woof!");
};

dog.eat(); // 'eating...' - animal의 메서드를 위임받아 실행
dog.bark(); // 'woof!' - 자신의 메서드 실행
```

### 프로토타입 패턴과 JavaScript의 자연스러운 결합

```js
// 기본 프로토타입 패턴 구현
const baseShape = {
  type: "circle",
  color: "red",
  clone() {
    return Object.assign({}, this);
  },
  // 깊은 복사를 위한 메서드
  deepClone() {
    return JSON.parse(JSON.stringify(this));
  },
};

const anotherShape = baseShape.clone();
anotherShape.color = "blue";
console.log(baseShape.color); // 'red' - 원본은 변경되지 않음
console.log(anotherShape.color); // 'blue'
```

### 생성자 함수와 프로토타입

```js
// 생성자 함수를 통한 프로토타입 활용
function Shape(type, color) {
  this.type = type;
  this.color = color;
}

Shape.prototype.clone = function () {
  return new this.constructor(this.type, this.color);
};

Shape.prototype.describe = function () {
  return `${this.color} ${this.type}`;
};

const circle = new Shape("circle", "red");
const clonedCircle = circle.clone();
console.log(clonedCircle.describe()); // "red circle"
```

### ES6 클래스와 프로토타입

```js
// ES6 클래스도 내부적으로는 프로토타입을 사용
class ModernShape {
  constructor(type, color) {
    this.type = type;
    this.color = color;
  }

  clone() {
    return new this.constructor(this.type, this.color);
  }

  // 정적 메서드로 팩토리 패턴과 결합
  static createPrototype(type, color) {
    const prototype = new this(type, color);
    prototype.isPrototype = true;
    return prototype;
  }
}

const shapePrototype = ModernShape.createPrototype("rectangle", "green");
const newShape = shapePrototype.clone();
```
