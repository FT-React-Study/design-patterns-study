# [옵저버 패턴](https://patterns-dev-kr.github.io/design-patterns/observer-pattern/)

## 패턴 개요

옵저버 패턴은 특정 객체들(Observer)이 다른 객체(Observable)를 구독할 수 있는 디자인 패턴임. 이벤트가 발생하면 Observable은 등록된 모든 Observer들에게 이벤트를 전파함

## 옵저버 패턴이란

- 하나의 객체(Subject/Observable)의 상태가 바뀔 때, 그 객체에 의존하는 다른 객체들(Observer)에게 자동으로 알림을 전달하는 패턴
- "일대다 의존성"을 정의하여 한 객체가 변경되면 그에 의존하는 모든 객체들이 자동으로 갱신됨
- 발행-구독(Publish-Subscribe) 패턴과 유사하지만, 옵저버 패턴은 직접적인 의존 관계를 가짐

## JavaScript에서의 옵저버 패턴 구현

### 기본 구현 방식 (ES6 클래스)

```javascript
class Observable {
  constructor() {
    this.observers = [];
  }

  subscribe(func) {
    this.observers.push(func);
  }

  unsubscribe(func) {
    this.observers = this.observers.filter(observer => observer !== func);
  }

  notify(data) {
    this.observers.forEach(observer => observer(data));
  }
}

// 사용 예시
const observable = new Observable();

const observer1 = data => console.log(`Observer 1: ${data}`);
const observer2 = data => console.log(`Observer 2: ${data}`);

observable.subscribe(observer1);
observable.subscribe(observer2);
observable.notify('Hello Observers!');
```

### 객체 기반 Observer 구현

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received:`, data);
  }
}
```

### EventTarget을 활용한 구현

```javascript
class EventObserver extends EventTarget {
  constructor() {
    super();
    this.data = null;
  }

  setData(data) {
    this.data = data;
    this.dispatchEvent(new CustomEvent('dataChange', { detail: data }));
  }
}

const observer = new EventObserver();
observer.addEventListener('dataChange', (event) => {
  console.log('Data changed:', event.detail);
});

observer.setData('New data');
```

## 실제 활용 사례

- 사용자 상호작용 추적
- 이벤트 로깅
- 알림 전송
- 비동기 데이터 처리 관리
- 상태 관리 라이브러리 (Redux, MobX, Vuex 등)
- 모델-뷰 바인딩 (Vue.js의 반응성 시스템)

## 장단점

### 장점

- 관심사의 분리 강제
- Observable과 Observer 간의 느슨한 결합
- 런타임에 Observer를 동적으로 추가/제거 가능
- 이벤트 기반 프로그래밍 지원
- 개방-폐쇄 원칙 준수

### 단점

- 복잡한 Observer 네트워크에서는 성능 저하 가능
- 메모리 누수 위험 - Observer를 제대로 제거하지 않을 경우
- 무한 루프 위험 - Observer가 다시 Subject를 변경하는 경우
- 디버깅 어려움 - 간접적인 업데이트로 인한 호출 흐름 추적 어려움

## RxJS와 옵저버 패턴

RxJS는 옵저버 패턴을 구현한 대표적인 라이브러리로, 고급 이벤트 관리 기능을 제공함

```javascript
import { Subject } from 'rxjs';

const subject = new Subject();

// Observer들 등록
subject.subscribe(value => console.log(`Observer A: ${value}`));
subject.subscribe(value => console.log(`Observer B: ${value}`));

// 이벤트 발생
subject.next('Hello RxJS!');
```

## 브라우저 Observer API들

### MutationObserver

DOM 변화를 감지하는 브라우저 API로, DOM 트리의 변경사항을 비동기적으로 관찰함

```javascript
const targetNode = document.getElementById('app');

const observer = new MutationObserver((mutationsList) => {
  for (const mutation of mutationsList) {
    if (mutation.type === 'childList') {
      console.log('Child node added or removed');
    } else if (mutation.type === 'attributes') {
      console.log(`Attribute ${mutation.attributeName} changed`);
    }
  }
});

// 관찰 시작
observer.observe(targetNode, {
  attributes: true,          // 속성 변화 감지
  childList: true,          // 자식 노드 변화 감지
  subtree: true,            // 하위 트리까지 감지
  attributeOldValue: true,  // 이전 속성값 포함
  characterData: true       // 텍스트 노드 변화 감지
});

// 관찰 중단
// observer.disconnect();
```

활용 사례:
- 동적으로 추가된 DOM 요소 감지
- 라이브러리나 서드파티 스크립트의 DOM 변경 감지
- 무한 스크롤이나 가상 스크롤 구현
- 접근성 개선을 위한 DOM 변화 추적
- SPA에서 라우팅 변화 감지

### ResizeObserver

요소의 크기 변화를 감지하는 API로, `window.resize` 이벤트보다 정확하고 효율적임

```javascript
const resizeObserver = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { width, height } = entry.contentRect;
    console.log(`Element resized: ${width}x${height}`);
    
    // 크기에 따른 처리
    if (width < 768) {
      entry.target.classList.add('mobile');
    } else {
      entry.target.classList.remove('mobile');
    }
    
    // 차트 리사이징 예시
    if (entry.target.classList.contains('chart')) {
      updateChart(entry.target, width, height);
    }
  }
});

// 관찰할 요소 추가
const element = document.querySelector('.responsive-element');
resizeObserver.observe(element);

// 관찰 중단
// resizeObserver.unobserve(element);
```

활용 사례:
- 반응형 컴포넌트 구현
- 차트나 그래프의 동적 리사이징
- 텍스트 영역의 자동 크기 조절
- 컨테이너 쿼리 폴리필 구현
- 레이아웃 변화에 따른 UI 조정

### IntersectionObserver

요소가 뷰포트나 다른 요소와 교차하는 시점을 감지하는 API

```javascript
const options = {
  root: null,           // 뷰포트를 기준으로 함 (null이면 뷰포트)
  rootMargin: '50px',   // root의 마진 설정
  threshold: [0, 0.25, 0.5, 0.75, 1.0] // 교차 비율 임계값
};

const intersectionObserver = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      const ratio = entry.intersectionRatio;
      console.log(`Element is ${Math.round(ratio * 100)}% visible`);
      
      // 이미지 지연 로딩
      if (entry.target.dataset.src && !entry.target.src) {
        entry.target.src = entry.target.dataset.src;
        entry.target.removeAttribute('data-src');
        intersectionObserver.unobserve(entry.target);
      }
      
      // 애니메이션 트리거
      if (entry.target.classList.contains('animate-on-scroll')) {
        entry.target.classList.add('animated');
      }
    } else {
      // 뷰포트에서 벗어남
      entry.target.classList.remove('animated');
    }
  });
}, options);

// 관찰할 요소들 추가
document.querySelectorAll('img[data-src]').forEach((img) => {
  intersectionObserver.observe(img);
});

document.querySelectorAll('.animate-on-scroll').forEach((el) => {
  intersectionObserver.observe(el);
});
```

활용 사례:
- 이미지 지연 로딩 (Lazy Loading)
- 무한 스크롤 구현
- 애니메이션 트리거 (스크롤 기반)
- 광고 뷰어빌리티 측정
- 페이지 네비게이션 하이라이트
- 성능 최적화를 위한 컴포넌트 렌더링 제어

## 옵저버 패턴 vs Observer API

| 구분 | 옵저버 패턴 | Browser Observer API |
|------|-------------|---------------------|
| 구현 주체 | 개발자가 직접 구현 | 브라우저 네이티브 API |
| 대상 | 일반적인 객체 상태 | 특정 DOM/브라우저 이벤트 |
| 성능 | 구현에 따라 차이 | 브라우저 최적화됨 |
| 메모리 관리 | 수동 관리 필요 | 브라우저가 자동 관리 |
| 사용 복잡도 | 높음 | 상대적으로 간단 |
| 유연성 | 높음 | 특정 용도에 제한됨 |

## React에서의 옵저버 패턴

```javascript
// Context API를 활용한 옵저버 패턴
const ThemeContext = React.createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  
  // Observer들에게 알림을 전달하는 역할
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Observer 역할을 하는 컴포넌트
const ThemeButton = () => {
  const { theme, setTheme } = useContext(ThemeContext);
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Current theme: {theme}
    </button>
  );
};

// Custom Hook으로 Observer 패턴 구현
const useObserver = () => {
  const [observers, setObservers] = useState([]);
  
  const subscribe = useCallback((callback) => {
    setObservers(prev => [...prev, callback]);
    return () => setObservers(prev => prev.filter(cb => cb !== callback));
  }, []);
  
  const notify = useCallback((data) => {
    observers.forEach(callback => callback(data));
  }, [observers]);
  
  return { subscribe, notify };
};
```

옵저버 패턴은 현대 웹 개발에서 상태 관리와 반응형 프로그래밍의 핵심 개념이며, 브라우저의 Observer API들과 함께 사용하면 더욱 강력하고 효율적인 사용자 경험을 제공할 수 있음
