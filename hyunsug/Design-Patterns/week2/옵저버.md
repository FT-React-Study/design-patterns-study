# [옵저버 패턴](https://patterns-dev-kr.github.io/design-patterns/observer-pattern/)

## 정의

- 특정 객체들(Observer)이 다른 객체(Observable)를 구독하는 디자인 패턴
- 이벤트 발생 시 Observable이 등록된 모든 Observer들에게 이벤트 전파

## 특징

- Subject/Observable 상태 변경 시 의존하는 Observer들에게 자동 알림 전달
- 일대다 의존성 구조로 한 객체 변경 시 의존 객체들 자동 갱신
- 발행-구독 패턴과 유사하나 직접적 의존 관계 보유

## JavaScript에서의 옵저버 패턴 구현

### 기본 구현 방식 (ES6 클래스)

```javascript
class Observable {
  constructor() {
    this.observers = [];
  }

  subscribe(func) {
    this.observers.push(func);
  }

  unsubscribe(func) {
    this.observers = this.observers.filter((observer) => observer !== func);
  }

  notify(data) {
    this.observers.forEach((observer) => observer(data));
  }
}

// 사용 예시
const observable = new Observable();

const observer1 = (data) => console.log(`Observer 1: ${data}`);
const observer2 = (data) => console.log(`Observer 2: ${data}`);

observable.subscribe(observer1);
observable.subscribe(observer2);
observable.notify("Hello Observers!");
```

### 객체 기반 Observer 구현

```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received:`, data);
  }
}
```

### EventTarget을 활용한 구현

```javascript
class EventObserver extends EventTarget {
  constructor() {
    super();
    this.data = null;
  }

  setData(data) {
    this.data = data;
    this.dispatchEvent(new CustomEvent("dataChange", { detail: data }));
  }
}

const observer = new EventObserver();
observer.addEventListener("dataChange", (event) => {
  console.log("Data changed:", event.detail);
});

observer.setData("New data");
```

## 실제 활용 사례

- 사용자 상호작용 추적
- 이벤트 로깅
- 알림 전송
- 비동기 데이터 처리 관리
- 상태 관리 라이브러리 (Redux, MobX, Vuex 등)
- 모델-뷰 바인딩 (Vue.js의 반응성 시스템)

## 장단점

### 장점

- 관심사의 분리 강제
- Observable과 Observer 간의 느슨한 결합
- 런타임에 Observer를 동적으로 추가/제거 가능
- 이벤트 기반 프로그래밍 지원
- 개방-폐쇄 원칙 준수

### 단점

- 복잡한 Observer 네트워크에서는 성능 저하 가능
- 메모리 누수 위험 - Observer를 제대로 제거하지 않을 경우
- 무한 루프 위험 - Observer가 다시 Subject를 변경하는 경우
- 디버깅 어려움 - 간접적인 업데이트로 인한 호출 흐름 추적 어려움

## RxJS와 옵저버 패턴

RxJS는 옵저버 패턴을 구현한 대표적인 라이브러리로, 고급 이벤트 관리 기능을 제공함

```javascript
import { Subject } from "rxjs";

const subject = new Subject();

// Observer들 등록
subject.subscribe((value) => console.log(`Observer A: ${value}`));
subject.subscribe((value) => console.log(`Observer B: ${value}`));

// 이벤트 발생
subject.next("Hello RxJS!");
```

## 브라우저 Observer API들

### MutationObserver

DOM 변화를 감지하는 브라우저 API로, DOM 트리의 변경사항을 비동기적으로 관찰함

```javascript
const targetNode = document.getElementById("app");

const observer = new MutationObserver((mutationsList) => {
  for (const mutation of mutationsList) {
    if (mutation.type === "childList") {
      console.log("Child node added or removed");
    } else if (mutation.type === "attributes") {
      console.log(`Attribute ${mutation.attributeName} changed`);
    }
  }
});

// 관찰 시작
observer.observe(targetNode, {
  attributes: true, // 속성 변화 감지
  childList: true, // 자식 노드 변화 감지
  subtree: true, // 하위 트리까지 감지
  attributeOldValue: true, // 이전 속성값 포함
  characterData: true, // 텍스트 노드 변화 감지
});

// 관찰 중단
// observer.disconnect();
```

- 동적 DOM 요소 감지
- 서드파티 스크립트 DOM 변경 감지
- 무한/가상 스크롤 구현
- 접근성 개선용 DOM 변화 추적
- SPA 라우팅 변화 감지

### ResizeObserver

요소의 크기 변화를 감지하는 API로, `window.resize` 이벤트보다 정확하고 효율적임

```javascript
const resizeObserver = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { width, height } = entry.contentRect;
    console.log(`Element resized: ${width}x${height}`);

    // 크기에 따른 처리
    if (width < 768) {
      entry.target.classList.add("mobile");
    } else {
      entry.target.classList.remove("mobile");
    }

    // 차트 리사이징 예시
    if (entry.target.classList.contains("chart")) {
      updateChart(entry.target, width, height);
    }
  }
});

// 관찰할 요소 추가
const element = document.querySelector(".responsive-element");
resizeObserver.observe(element);

// 관찰 중단
// resizeObserver.unobserve(element);
```

- 반응형 컴포넌트 구현
- 차트/그래프 동적 리사이징
- 텍스트 영역 자동 크기 조절
- 컨테이너 쿼리 폴리필 구현
- 레이아웃 변화 대응 UI 조정

### IntersectionObserver

요소가 뷰포트나 다른 요소와 교차하는 시점을 감지하는 API

```javascript
const options = {
  root: null, // 뷰포트를 기준으로 함 (null이면 뷰포트)
  rootMargin: "50px", // root의 마진 설정
  threshold: [0, 0.25, 0.5, 0.75, 1.0], // 교차 비율 임계값
};

const intersectionObserver = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      const ratio = entry.intersectionRatio;
      console.log(`Element is ${Math.round(ratio * 100)}% visible`);

      // 이미지 지연 로딩
      if (entry.target.dataset.src && !entry.target.src) {
        entry.target.src = entry.target.dataset.src;
        entry.target.removeAttribute("data-src");
        intersectionObserver.unobserve(entry.target);
      }

      // 애니메이션 트리거
      if (entry.target.classList.contains("animate-on-scroll")) {
        entry.target.classList.add("animated");
      }
    } else {
      // 뷰포트에서 벗어남
      entry.target.classList.remove("animated");
    }
  });
}, options);

// 관찰할 요소들 추가
document.querySelectorAll("img[data-src]").forEach((img) => {
  intersectionObserver.observe(img);
});

document.querySelectorAll(".animate-on-scroll").forEach((el) => {
  intersectionObserver.observe(el);
});
```

- 이미지 지연 로딩
- 무한 스크롤 구현
- 스크롤 기반 애니메이션 트리거
- 광고 뷰어빌리티 측정
- 페이지 네비게이션 하이라이트
- 성능 최적화용 컴포넌트 렌더링 제어

## 옵저버 패턴 vs Observer API

| 구분        | 옵저버 패턴        | Browser Observer API     |
| ----------- | ------------------ | ------------------------ |
| 구현 주체   | 개발자가 직접 구현 | 브라우저 네이티브 API    |
| 대상        | 일반적인 객체 상태 | 특정 DOM/브라우저 이벤트 |
| 성능        | 구현에 따라 차이   | 브라우저 최적화됨        |
| 메모리 관리 | 수동 관리 필요     | 브라우저가 자동 관리     |
| 사용 복잡도 | 높음               | 상대적으로 간단          |
| 유연성      | 높음               | 특정 용도에 제한됨       |

## React에서의 옵저버 패턴

```javascript
// Context API를 활용한 옵저버 패턴
const ThemeContext = React.createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState("light");

  // Observer들에게 알림을 전달하는 역할
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Observer 역할을 하는 컴포넌트
const ThemeButton = () => {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      Current theme: {theme}
    </button>
  );
};

// Custom Hook으로 Observer 패턴 구현
const useObserver = () => {
  const [observers, setObservers] = useState([]);

  const subscribe = useCallback((callback) => {
    setObservers((prev) => [...prev, callback]);
    return () => setObservers((prev) => prev.filter((cb) => cb !== callback));
  }, []);

  const notify = useCallback(
    (data) => {
      observers.forEach((callback) => callback(data));
    },
    [observers]
  );

  return { subscribe, notify };
};
```

- 현대 웹 개발 상태 관리와 반응형 프로그래밍에 활용 가능
- 브라우저 Observer API와 결합 시 강력하고 효율적인 UX 제공
