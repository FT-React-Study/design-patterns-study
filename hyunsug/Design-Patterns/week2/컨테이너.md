# [컨테이너/프레젠테이셔널 패턴](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/)

## 정의

- React 애플리케이션에서 관심사 분리(Separation of Concerns) 구현 패턴
- 비즈니스 로직과 UI 렌더링 명확한 분리
- 코드 재사용성과 유지보수성 향상

## 컴포넌트 구분

### Presentational Components

- UI 렌더링만 담당 (화면 표시 전용)
- Props로 데이터 수신 (상위 컴포넌트에서)
- 스타일시트 포함 (시각적 표현 집중)
- 데이터 수정 금지 (읽기 전용)
- 함수형 컴포넌트 구현 가능

```jsx
// Presentational Component 예시
const UserProfile = ({ user, onEdit }) => (
  <div className="user-profile">
    <img src={user.avatar} alt={user.name} />
    <h2>{user.name}</h2>
    <p>{user.email}</p>
    <button onClick={onEdit}>프로필 수정</button>
  </div>
);
```

### Container Components

- 데이터 로직 처리 (상태 관리, 비즈니스 로직)
- 외부 API 호출 (서버 통신)
- Presentational 컴포넌트에 Props로 데이터 전달
- 직접 렌더링 금지 (UI는 하위 컴포넌트에 위임)

```jsx
// Container Component 예시
const UserProfileContainer = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUserData()
      .then(setUser)
      .finally(() => setLoading(false));
  }, []);

  const handleEdit = () => {
    // 편집 로직 처리
  };

  if (loading) return <LoadingSpinner />;

  return <UserProfile user={user} onEdit={handleEdit} />;
};
```

## 장점

- 관심사 분리 강제 (비즈니스 로직과 UI 로직 명확한 분리)
- 컴포넌트 재사용성 향상 (Presentational 컴포넌트를 다양한 Container에서 재사용)
- 코드 이해와 유지보수 용이 (각 컴포넌트 역할 명확)
- 테스트 용이 (UI와 로직 독립적 테스트)

## 한계

- 소규모 앱에서 오버엔지니어링 (단순 컴포넌트에 불필요한 복잡성)
- 보일러플레이트 코드 증가 (작은 기능에도 두 컴포넌트 필요)

## Dan Abramov의 원본 제안과 견해 변화

### 원본 제안 (2015)

- Medium: [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
- React 컴포넌트 Smart/Dumb, Fat/Skinny, Stateful/Pure 구분 패턴 제안
- 복잡한 상태 로직을 컴포넌트 다른 측면에서 분리

### 2019년 업데이트 - Hook 시대 재평가

Dan Abramov 2019년 업데이트:

> "I wrote this article a long time ago and my views have since evolved. In particular, I don't suggest splitting your components like this anymore."

#### 주요 변화

- Hook 등장으로 인한 패러다임 변화
  - "Hooks let me do the same thing without an arbitrary division"
  - 인위적 컴포넌트 분리 없이도 같은 목적 달성
- 패턴의 과도한 사용 우려
  - 필요성 없이 교조적 강요 빈발
- 현재 권장사항
  - 패턴 자체는 valid하나 적극 권장 중단
  - Custom Hook을 통한 로직 분리 선호

### Hook 시대의 대안

```jsx
// 기존 Container/Presentational 패턴
const UserProfileContainer = () => {
  const [user, setUser] = useState(null);
  // 로직...
  return <UserProfile user={user} onEdit={handleEdit} />;
};

// Custom Hook을 사용한 현대적 접근
const useUserProfile = () => {
  const [user, setUser] = useState(null);
  // 로직...
  return { user, handleEdit };
};

const UserProfile = () => {
  const { user, handleEdit } = useUserProfile();

  return <div className="user-profile">{/* UI 렌더링 */}</div>;
};
```

## React VAC 패턴 (View Asset Component)

### VAC 패턴 정의

- View Logic과 JSX 간 결합도 최소화 설계 방법
- Container/Presentational 패턴의 한 종류로 View 로직과 렌더링 더 명확한 분리
- JSX 영역을 Props Object로 추상화하여 View 컴포넌트에서 분리

### VAC 패턴 구성 요소

- **View Component (Container 역할)**
  - UI 기능과 상태 관리
  - Props Object로 VAC에 데이터 전달
  - 비즈니스 로직 처리
- **VAC Component (Pure Rendering)**
  - JSX와 스타일만 담당하는 순수 렌더링 컴포넌트
  - Stateless로 자체적 View 변경 금지
  - Props에 의해서만 제어

### VAC 패턴 구현 예시

```jsx
// View Component (로직 담당)
const UserView = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const handleEdit = () => {
    // 편집 로직
  };

  // Props Object로 VAC에 전달할 데이터 구성
  const vacProps = {
    user,
    loading,
    onEdit: handleEdit,
  };

  return <UserVAC {...vacProps} />;
};

// VAC Component (렌더링만 담당)
const UserVAC = ({ user, loading, onEdit }) => {
  if (loading) {
    return <div className="loading">로딩 중...</div>;
  }

  return (
    <div className="user-profile">
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={onEdit}>프로필 수정</button>
    </div>
  );
};
```

### VAC 패턴 장점

- 렌더링 로직 완전 분리 (JSX와 스타일 독립 관리)
- 디버깅 최적화 (VAC Debugger로 Props Object 분석)
- 테스트 용이성 (렌더링 로직과 비즈니스 로직 완전 분리)
- 재사용성 향상 (VAC 컴포넌트를 다양한 View에서 재사용)

- (개인적인 생각) 퍼블리셔의 전문적인 HTML 작성 능력을 뷰 컴포넌트에 활용하고, 프론트엔드 개발자의 비즈니스 로직을
  Action 컴포넌트에 활용하여 큰 팀에서의 협업에 매우 큰 장점을 보일 수 있지 않을까

### Container/Presentational vs VAC 비교

| 구분        | Container/Presentational   | VAC Pattern         |
| ----------- | -------------------------- | ------------------- |
| 관심사 분리 | 로직 vs UI                 | 로직 vs 렌더링(JSX) |
| View 로직   | Presentational에 일부 포함 | View에만 집중       |
| 순수성      | Presentational 상대적 순수 | VAC 완전 순수       |
| Props 구조  | 개별 props 전달            | Props Object 추상화 |
