# [컨테이너/프레젠테이셔널 패턴](https://patterns-dev-kr.github.io/design-patterns/container-presentational-pattern/)

## 패턴 개요

컨테이너/프레젠테이셔널 패턴은 React 애플리케이션에서 관심사의 분리(Separation of Concerns)를 구현하는 디자인 패턴임. 비즈니스 로직과 UI 렌더링을 명확하게 분리하여 코드의 재사용성과 유지보수성을 높임

## 두 가지 컴포넌트 유형

### 1. Presentational Components (프레젠테이셔널 컴포넌트)
- UI 렌더링만 담당 - 화면에 보이는 것만 처리
- Props를 통해 데이터 수신 - 상위 컴포넌트로부터 데이터를 받음
- 스타일시트 포함 - 시각적 표현에 집중
- 데이터 수정하지 않음 - 읽기 전용으로 데이터 사용
- 함수형 컴포넌트로 구현 가능

```jsx
// Presentational Component 예시
const UserProfile = ({ user, onEdit }) => (
  <div className="user-profile">
    <img src={user.avatar} alt={user.name} />
    <h2>{user.name}</h2>
    <p>{user.email}</p>
    <button onClick={onEdit}>프로필 수정</button>
  </div>
);
```

### 2. Container Components (컨테이너 컴포넌트)
- 데이터 로직 처리 - 상태 관리, 비즈니스 로직 담당
- 외부 API 호출 - 서버와의 통신 처리
- Presentational 컴포넌트에 데이터 전달 - Props로 데이터 제공
- 화면에 직접 렌더링하지 않음 - UI는 하위 컴포넌트에 위임

```jsx
// Container Component 예시
const UserProfileContainer = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUserData()
      .then(setUser)
      .finally(() => setLoading(false));
  }, []);

  const handleEdit = () => {
    // 편집 로직 처리
  };

  if (loading) return <LoadingSpinner />;
  
  return <UserProfile user={user} onEdit={handleEdit} />;
};
```

## 패턴의 장점

- 관심사 분리 강제 - 비즈니스 로직과 UI 로직의 명확한 분리
- 컴포넌트 재사용성 향상 - Presentational 컴포넌트를 다양한 Container에서 재사용
- 코드 이해와 유지보수 용이 - 각 컴포넌트의 역할이 명확함
- 테스트 용이 - UI와 로직을 독립적으로 테스트 가능

## 패턴의 한계

- 소규모 앱에서는 오버엔지니어링 - 단순한 컴포넌트에는 불필요한 복잡성
- 보일러플레이트 코드 증가 - 작은 기능에도 두 개의 컴포넌트 필요

## Dan Abramov의 원본 제안과 견해 변화

### 원본 글 (2015)
- Medium 글: [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
- React 컴포넌트를 Smart/Dumb, Fat/Skinny, Stateful/Pure 등으로 구분하는 패턴 제안
- 복잡한 상태 로직을 컴포넌트의 다른 측면들로부터 분리하는 것이 주요 목적

### 2019년 업데이트 - Hook 시대의 재평가

Dan Abramov는 2019년 원본 글에 다음과 같은 업데이트를 추가했습니다:

> "Update from 2019: I wrote this article a long time ago and my views have since evolved. In particular, I don't suggest splitting your components like this anymore."

#### 주요 변화 포인트

1. Hook의 등장으로 인한 패러다임 변화
   - "The main reason I found it useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division."
   - Hook을 통해 인위적인 컴포넌트 분리 없이도 같은 목적 달성 가능

2. 패턴의 과도한 사용에 대한 우려
   - "If you find it natural in your codebase, this pattern can be handy. But I've seen it enforced without any necessity and with almost dogmatic fervor far too many times."
   - 필요성 없이 교조적으로 강요되는 경우가 많다는 지적

3. 현재 권장사항
   - 패턴 자체는 여전히 valid하지만 더 이상 적극 권장하지 않음
   - Custom Hook을 통한 로직 분리를 더 선호

### Hook 시대의 대안

```jsx
// 기존 Container/Presentational 패턴
const UserProfileContainer = () => {
  const [user, setUser] = useState(null);
  // 로직...
  return <UserProfile user={user} onEdit={handleEdit} />;
};

// Custom Hook을 사용한 현대적 접근
const useUserProfile = () => {
  const [user, setUser] = useState(null);
  // 로직...
  return { user, handleEdit };
};

const UserProfile = () => {
  const { user, handleEdit } = useUserProfile();
  
  return (
    <div className="user-profile">
      {/* UI 렌더링 */}
    </div>
  );
};
```

## React VAC 패턴 (View Asset Component)

### VAC 패턴 개요
- **VAC (View Asset Component)** 패턴은 **View Logic과 JSX 간의 결합도를 최소화**하는 설계 방법
- Container/Presentational 패턴의 한 종류이지만, **View 로직(UI 기능, 상태 관리)과 렌더링(JSX)을 더 명확히 분리**
- JSX 영역을 'Props Object'로 추상화하여 View 컴포넌트에서 분리

### VAC 패턴의 구성 요소

1. **View Component (Container 역할)**
   - UI 기능과 상태 관리 담당
   - Props Object를 통해 VAC에 데이터 전달
   - 비즈니스 로직 처리

2. **VAC Component (Pure Rendering)**
   - **JSX와 스타일만 담당**하는 순수 렌더링 컴포넌트
   - **Stateless** - 자체적으로 View를 변경하지 않음
   - Props에 의해서만 제어되는 컴포넌트

### VAC 패턴 구현 예시

```jsx
// View Component (로직 담당)
const UserView = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const handleEdit = () => {
    // 편집 로직
  };

  // Props Object로 VAC에 전달할 데이터 구성
  const vacProps = {
    user,
    loading,
    onEdit: handleEdit,
  };

  return <UserVAC {...vacProps} />;
};

// VAC Component (렌더링만 담당)
const UserVAC = ({ user, loading, onEdit }) => {
  if (loading) {
    return <div className="loading">로딩 중...</div>;
  }

  return (
    <div className="user-profile">
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={onEdit}>프로필 수정</button>
    </div>
  );
};
```

### VAC 패턴의 장점

- 렌더링 로직의 완전한 분리 - JSX와 스타일만 독립적으로 관리
- 디버깅 최적화 - VAC Debugger를 통한 Props Object 분석 가능
- 테스트 용이성 - 렌더링 로직과 비즈니스 로직을 완전히 분리하여 테스트
- 재사용성 향상 - VAC 컴포넌트를 다양한 View에서 재사용 가능

### Container/Presentational vs VAC

| 구분 | Container/Presentational | VAC Pattern |
|------|-------------------------|-------------|
| 관심사 분리 | 로직 vs UI | 로직 vs 렌더링(JSX) |
| View 로직 | Presentational에 일부 포함 | View에만 집중 |
| 순수성 | Presentational이 상대적으로 순수 | VAC는 완전히 순수 |
| Props 구조 | 개별 props 전달 | Props Object로 추상화 |
